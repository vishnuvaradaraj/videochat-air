package p2p{	import events.ChatEvent;	import events.ConnectionStatusEvent;	import events.PeerMessageEvent;	import events.PeerStatusEvent;	import events.StatusInfoEvent;	import events.UserEvent;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.NetStatusEvent;	import flash.net.GroupSpecifier;	import flash.net.NetConnection;	import flash.net.NetGroup;	import flash.net.NetGroupReceiveMode;	import flash.net.NetGroupSendMode;	import flash.net.NetGroupSendResult;	import flash.net.NetStream;		import model.Globals;
		[Event(name="statusInfo",type="events.StatusInfoEvent")]	[Event(name="chatMessage",type="events.PeerMessageEvent")]	[Event(name="openPrivateChat",type="events.PeerMessageEvent")]	[Event(name="connect", type="flash.events.Event")]	[Event(name="close", type="flash.events.Event")]	[Event(name="netStatus",type="flash.events.NetStatus")]	[Event(name="statusChange",type="flash.events.ConnectionStatusEvent")]	/**	 * controls a P2P session, NetConnection, NetGroup and all related management	 */	[Bindable]	public class P2PSession extends EventDispatcher	{		private var SERVER:String = "rtmfp://p2p.rtmfp.net/358baf8187066465c7c83c08-f38caed452ff/";		private var KEY:String = "358baf8187066465c7c83c08-f38caed452ff";				public static var connection:NetConnection;		public var group:NetGroup;				public static var myUser:UserObject;						public var status:uint;				public var userName:String;				public var chatGroup:GroupChat;				public static var debugMode:Boolean = false;				private var chatSequence:uint = 0;				public function P2PSession()		{		}				/**		 * Connect to Adobe Stratus Rendezvous Service		 */		public function connect(user:UserObject):void		{			this.userName = user.nick;			myUser = user;						connection = new NetConnection();			connection.addEventListener(NetStatusEvent.NET_STATUS, netStatus, false,0, true);						connection.connect(SERVER+KEY);						changeStatus(ConnectionStatusEvent.CONNECTING);					}				public static function getConnection():NetConnection		{			return connection;		}				/**		 * Close connection and reset		 */		public function disconnect():void		{			if (chatGroup)			{				chatGroup.close();				chatGroup=null;			}						if (connection)			{				connection.close();				connection = null;			}		}				/**		 * Join group		 */		public function join():void		{						chatGroup = new GroupChat(connection, getGroupSpec().groupspecWithAuthorizations(), myUser);							group = chatGroup;						group.addEventListener(NetStatusEvent.NET_STATUS, netStatus, false, 0, true);		}				/**		 * calls other users using Directed Routing and opens chat		 */		public function openPrivateChat(withUsers:Vector.<UserObject>):void		{						var groupName:String = "GROUP"+Math.round(Math.random()*100000);						var arr:Array = new Array();			for(var ia:uint = 0; ia<withUsers.length;ia++)			{				arr.push(withUsers[ia].nick);			}			arr.sort();			groupName = arr.join("/");						for(var i:uint = 0; i<withUsers.length;i++)			{								var msgObj:Object = new Object();				msgObj.nick = myUser.nick;				msgObj.type = "openPrivateChat";				msgObj.sender = myUser;				msgObj.sequence = chatSequence++;				msgObj.withUsers = withUsers;				msgObj.groupName = groupName;								debugWrite("chatSendPrivate "+withUsers[i].peerId+" - "+msgObj.type)								debugWrite(group.sendToNearest(msgObj, group.convertPeerIDToGroupAddress(withUsers[i].id)));			}		}				/**		 * calls other users using Directed Routing and informs the user of an incoming call		 */		public function sendCallEvent(type:String, withUsers:Vector.<UserObject>):void		{						var groupName:String = "GROUP"+Math.round(Math.random()*100000);						var arr:Array = new Array();			for(var ia:uint = 0; ia<withUsers.length;ia++)			{				arr.push(withUsers[ia].nick);			}			arr.sort();			groupName = arr.join("/");						for(var i:uint = 0; i<withUsers.length;i++)			{								var msgObj:Object = new Object();				msgObj.nick = myUser.nick;				msgObj.type = type;				msgObj.sender = myUser;				msgObj.sequence = chatSequence++;				msgObj.withUsers = withUsers;				msgObj.groupName = groupName;								debugWrite("\n"+type+" "+withUsers[i].nick+" - "+msgObj.type)								debugWrite(group.sendToNearest(msgObj, group.convertPeerIDToGroupAddress(withUsers[i].id)));			}					}							public function pingUser(peerID:String):Boolean		{			var ret:Boolean = true;						var msgObj:Object = new Object();			msgObj.type = "ping";						if (group)			{				if (NetGroupSendResult.SENT != group.sendToNearest(msgObj, group.convertPeerIDToGroupAddress(peerID)))				{					//debugWrite("Failed to call user");					ret = false;				}			}						return ret;		}		public function sendCallEventToPeerIds(type:String, withUsers:Vector.<String>):Boolean		{			var ret:Boolean = true;			var groupName:String = "GROUP"+Math.round(Math.random()*100000);									for(var i:uint = 0; i<withUsers.length;i++)			{								var msgObj:Object = new Object();				msgObj.nick = myUser.nick;				msgObj.type = type;				msgObj.sender = myUser;				msgObj.sequence = chatSequence++;				msgObj.withUsers = withUsers;				msgObj.groupName = groupName;								debugWrite(withUsers[i]+" - "+msgObj.type)								if (NetGroupSendResult.SENT != group.sendToNearest(msgObj, group.convertPeerIDToGroupAddress(withUsers[i])))				{					debugWrite("Failed to call user");					ret = false;				}			}						return ret;		}					/**		 * this is getting called by openPrivateChat through Directed Routing		 */		public function openPrivateChatReceive(message:Object):void		{			dispatchEvent(new PeerMessageEvent(PeerMessageEvent.OPEN_PRIVATE_CHAT, message));		}				public function processPrivateChat(msg:Object):void		{			dispatchEvent(new ChatEvent(ChatEvent.NEW_MESSAGE, msg));		}				public function getUserCount():Number		{			if(group==null)			{				return 0;			}			return group.estimatedMemberCount;		}				public function getNeighborCount():Number		{			if(group==null)			{				return 0;			}			return group.neighborCount;		}				// Handlers		/**		 * Dispatched when user connects to Stratus		 */		protected function onConnect():void		{			join();		}				/**		 * Dispatched when user disconnects from Stratus		 */		protected function onDisconnect():void		{			dispatchEvent(new Event(Event.CLOSE));		}				/**		 * when user connects to a group, create a user object and assign groupAddress, peerID...		 */		public function onNetGroupConnect():void		{			myUser.id = connection.nearID;			myUser.peerId = group.convertPeerIDToGroupAddress(connection.nearID);						dispatchEvent(new Event(Event.CONNECT));		}				public function returnUser():UserObject		{			return myUser;		}				public function get isConnected():Boolean		{			if(status == ConnectionStatusEvent.CONNECTED_GROUP)			{				return true;			}			return false;		}				// PROTECTED				/**		 * returns GroupSpecifier String, here you can enable, disable group params		 */		protected function getGroupSpec():GroupSpecifier		{			var groupspec:GroupSpecifier = new GroupSpecifier("com.parabay.p2p");			groupspec.ipMulticastMemberUpdatesEnabled=true;			groupspec.addIPMulticastAddress("239.255.255.254:30001"); // Use multi-cast to find local network peers 			groupspec.serverChannelEnabled = true;			groupspec.postingEnabled = true;			groupspec.routingEnabled = true;			groupspec.objectReplicationEnabled = true;			return groupspec;		}				/**		 * dispaches event, which is supposed to be written - debug and message info		 */		protected function statusWrite(str:String):void		{			Globals.LOG.info(str);			dispatchEvent(new StatusInfoEvent(StatusInfoEvent.CONN_STATUS_INFO, str));		}				protected function debugWrite(str:String):void		{			if(debugMode)			{				statusWrite(str);			}		}				protected function changeStatus(status:uint):void		{			this.status = status;			dispatchEvent(new ConnectionStatusEvent(ConnectionStatusEvent.STATUS_CHANGE,status));		}					/**		 * handles all net status events covering NetGroup		 */ 		protected function netStatus(e:NetStatusEvent):void		{					var globals:Globals = Globals.getInstance();			if (e.info.code != "NetGroup.Posting.Notify")				Globals.LOG.info(e.info.code);						switch(e.info.code)			{				case "NetConnection.Connect.Success":					changeStatus(ConnectionStatusEvent.CONNECTED);					onConnect();					break;								case "NetConnection.Connect.Closed":					changeStatus(ConnectionStatusEvent.DISCONNECTED);					onDisconnect();										break;								case "NetConnection.Connect.Failed":					changeStatus(ConnectionStatusEvent.FAILED);					onDisconnect();					break;								case "NetConnection.Connect.Rejected":				case "NetConnection.Connect.AppShutdown":				case "NetConnection.Connect.InvalidApp":    					onDisconnect();					break;												case "NetGroup.Connect.Success": // e.info.group					onNetGroupConnect();					changeStatus(ConnectionStatusEvent.CONNECTED_GROUP);					break;												case "NetGroup.Connect.Rejected": // e.info.group				case "NetGroup.Connect.Failed": // e.info.group					changeStatus(ConnectionStatusEvent.FAILED);					onDisconnect();					break;				case "NetGroup.SendTo.Notify": // e.info.message, e.info.from, e.info.fromLocal										Globals.LOG.info(e.info.message.type);					switch(e.info.message.type){						case "privateChat":							processPrivateChat(e.info.message);							break;						case "openPrivateChat":							openPrivateChatReceive(e.info.message);							break;						case "incomingCall":							if (e.info.message.sender)							{								var sender :UserObject = new UserObject(e.info.message.sender);								globals.p2pUsers[sender.id] = new P2PUser(sender, globals.callManager);								dispatchEvent(new PeerMessageEvent(PeerMessageEvent.INCOMING_CALL, e.info.message));							}							break;						case "acceptedCall":							if (e.info.message.sender)							{								var user :UserObject = new UserObject(e.info.message.sender);								globals.p2pUsers[user.id] = new P2PUser(user, globals.callManager);								dispatchEvent(new PeerMessageEvent(PeerMessageEvent.ACCEPTED_CALL, e.info.message));							}														break;						case "rejectedCall":							dispatchEvent(new PeerMessageEvent(PeerMessageEvent.REJECTED_CALL, e.info.message));							break;						case "endCall":							dispatchEvent(new PeerMessageEvent(PeerMessageEvent.END_CALL, e.info.message));							break;					}										break;								case "NetStream.Connect.Success":					dispatchEvent(new UserEvent(UserEvent.CONNECTED, e.info.stream));					break;								case "NetStream.Connect.Closed":					dispatchEvent(new UserEvent(UserEvent.DISCONNECTED, e.info.stream));					break;								case "NetGroup.Posting.Notify": // e.info.message, e.info.messageID				case "NetGroup.LocalCoverage.Notify": //				case "NetGroup.Neighbor.Connect": // e.info.neighbor				case "NetGroup.Neighbor.Disconnect": // e.info.neighbor				case "NetGroup.MulticastStream.PublishNotify": // e.info.name				case "NetGroup.MulticastStream.UnpublishNotify": // e.info.name				case "NetGroup.Replication.Fetch.SendNotify": // e.info.index				case "NetGroup.Replication.Fetch.Failed": // e.info.index				case "NetGroup.Replication.Fetch.Result": // e.info.index, e.info.object				case "NetGroup.Replication.Request": // e.info.index, e.info.requestID				default:					break;			}		}	}}